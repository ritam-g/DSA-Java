â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¢ BINARY SEARCH â€” CEILING OF A NUMBER (Java)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ¯ Problem Definition
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Given a sorted integer array `nums` and an integer `target`,
find the **smallest element â‰¥ target** (the "ceiling" of target).

If such an element does not exist, return -1.


ğŸ§© Example
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
nums   = [2, 3, 5, 9, 14, 16, 18]
target = 15

Ceiling = 16  (the smallest number â‰¥ 15)


âš™ï¸ Java Implementation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public class CeilingOfNumber {

    public static int ceiling(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;

        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (nums[mid] < target) {
                // Move right because ceiling must be larger
                start = mid + 1;
            } else {
                // nums[mid] >= target, possible ceiling, move left
                end = mid - 1;
            }
        }

        // After loop:
        // start â†’ index of smallest element â‰¥ target
        // If start == nums.length, ceiling does not exist
        if (start < nums.length) {
            return nums[start];
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] nums = {2, 3, 5, 9, 14, 16, 18};
        int target = 15;

        int result = ceiling(nums, target);
        System.out.println("Ceiling of " + target + " = " + result);
    }
}
ğŸ’¡ Output:

mathematica
Copy code
Ceiling of 15 = 16
ğŸ§  Step-by-Step Explanation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1ï¸âƒ£ Initialize:
â€¢ start = 0
â€¢ end = nums.length - 1

2ï¸âƒ£ While (start â‰¤ end):
â€¢ mid = start + (end - start) / 2
â€¢ If nums[mid] < target â†’ search right half (start = mid + 1)
â€¢ Else â†’ potential ceiling found, search left half (end = mid - 1)

3ï¸âƒ£ Loop exits when:
â€¢ end < start
â€¢ start now points to the first element â‰¥ target

4ï¸âƒ£ Therefore:
âœ… Ceiling = nums[start]
âŒ mid is just the last midpoint, not necessarily the ceiling.

ğŸ§® Example Trace
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
nums = [2, 3, 5, 9, 14, 16, 18], target = 15

start	end	mid	nums[mid]	Action
0	6	3	9	start = 4
4	6	5	16	end = 4
4	4	4	14	start = 5

Loop ends â†’ start = 5 â†’ nums[start] = 16 â†’ âœ… Ceiling

âš ï¸ Edge Case
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
If target > all elements:
â†’ start = nums.length
â†’ return -1 (no ceiling exists)

ğŸ“Š Time & Space Complexity
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Time Complexity: O(log n)
â€¢ Space Complexity: O(1)

âœ… Summary Table
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Variable	Meaning
start	Points to first element â‰¥ target (ceiling)
end	Points to last element < target
mid	Just midpoint for comparison (not final)

ğŸš« Therefore: always return nums[start], not nums[mid].

ğŸ” Mirror Concept: Floor of a Number
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
For the "Floor" (largest element â‰¤ target):
â€¢ If nums[mid] > target â†’ move left (end = mid - 1)
â€¢ Else â†’ move right (start = mid + 1)
â€¢ Return nums[end]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

yaml
Copy code

---
