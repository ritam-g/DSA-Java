//SECTION - 744. Find Smallest Letter Greater Than Target

You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.

Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.

Example 1:

Input: letters = ["c","f","j"], target = "a"
Output: "c"
Explanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.
Example 2:

Input: letters = ["c","f","j"], target = "c"
Output: "f"
Explanation: The smallest character that is lexicographically greater than 'c' in letters is 'f'.
Example 3:

Input: letters = ["x","x","y","y"], target = "z"
Output: "x"
Explanation: There are no characters in letters that is lexicographically greater than 'z' so we return letters[0].

                              //NOTE - ANSWER
//NOTE - NO NEED TO RETURN  THE TARGET ELEMENT IF IT MATCH WITH IDEX OF ARRAY 
//NOTE - JUST RETURN WHICH IS GETTER THAN AND NEARCST OF THE SELECTED ARRAY 
//NOTE - WRAPED IF NO GRTER VALUE IN ARRAY THEN RETURN ARR[0]

//SECTION - 34. Find First and Last Position of Element in Sorted Array
Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
Example 3:

Input: nums = [], target = 0
Output: [-1,-1]
 

Constraints:

0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums is a non-decreasing array.
-109 <= target <= 109

                                //NOTE - ANSWER


**Quick Checks â€” Why Two Binary Searches?**

1. One binary search â†’ finds **only one** occurrence.
2. We need both **first** and **last** positions â†’ use two searches.
3. `findFirst()` â†’ keep going **left** until previous â‰  target or index = 0.
4. `findLast()` â†’ keep going **right** until next â‰  target or index = end.
5. If only one search used â†’ may stop in the **middle of duplicates** (wrong range).
6. Example: `[5,7,7,8,8,8,10]`, target=8 â†’ single search may return index 4, but correct range is `[3,5]`.
7. Both searches = `O(log n)` each â†’ total still **O(log n)**.

**In short:**
ðŸ§  One search = one target.
âœ… Two searches = complete range.

                //!SECTION --- 852. Peak Index in a Mountain Array
You are given an integer mountain array arr of length n where the values increase to a peak element and then decrease.

Return the index of the peak element.

Your task is to solve it in O(log(n)) time complexity.

 

Example 1:

Input: arr = [0,1,0]

Output: 1

Example 2:

Input: arr = [0,2,1,0]

Output: 1

Example 3:

Input: arr = [0,10,5,2]

Output: 1

 

Constraints:

3 <= arr.length <= 105
0 <= arr[i] <= 106
arr is guaranteed to be a mountain array.
        //NOTE - ðŸ§  Quick Catch Points â€” LC 852 Peak Index in Mountain Array

Mountain â†’ first increase, then decrease (single peak).

Use binary search (O(log n)).

If arr[mid] < arr[mid+1] â†’ go right (left = mid + 1).

Else â†’ go left side (right = mid).

Loop ends when left == right â†’ thatâ€™s your peak index âœ…



