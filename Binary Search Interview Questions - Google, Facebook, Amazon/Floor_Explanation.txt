â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¢ BINARY SEARCH â€” FLOOR OF A NUMBER (Java)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ğŸ¯ Problem Definition
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Given a sorted integer array `nums` and an integer `target`,
find the **largest element â‰¤ target** (the "floor" of target).

If such an element does not exist, return -1.


ğŸ§© Example
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
nums   = [2, 3, 5, 9, 14, 16, 18]
target = 15

Floor = 14  (the largest number â‰¤ 15)


âš™ï¸ Java Implementation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
public class FloorOfNumber {

    public static int floor(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;

        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (nums[mid] > target) {
                // Move left because floor must be smaller
                end = mid - 1;
            } else {
                // nums[mid] <= target, possible floor, move right
                start = mid + 1;
            }
        }

        // After loop:
        // end â†’ index of largest element â‰¤ target
        // If end < 0, floor does not exist
        if (end >= 0) {
            return nums[end];
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] nums = {2, 3, 5, 9, 14, 16, 18};
        int target = 15;

        int result = floor(nums, target);
        System.out.println("Floor of " + target + " = " + result);
    }
}
ğŸ’¡ Output:

mathematica
Copy code
Floor of 15 = 14
ğŸ§  Step-by-Step Explanation
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1ï¸âƒ£ Initialize:
â€¢ start = 0
â€¢ end = nums.length - 1

2ï¸âƒ£ While (start â‰¤ end):
â€¢ mid = start + (end - start) / 2
â€¢ If nums[mid] > target â†’ move left (end = mid - 1)
â€¢ Else â†’ possible floor, move right (start = mid + 1)

3ï¸âƒ£ When loop ends:
â€¢ start > end
â€¢ end now points to the last element â‰¤ target

4ï¸âƒ£ Therefore:
âœ… Floor = nums[end]
âŒ mid is only valid within the loop, not afterward.

ğŸ§® Example Trace
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
nums = [2, 3, 5, 9, 14, 16, 18], target = 15

start	end	mid	nums[mid]	Action
0	6	3	9	start = 4
4	6	5	16	end = 4
4	4	4	14	start = 5

Loop ends â†’ end = 4 â†’ nums[end] = 14 â†’ âœ… Floor

âš ï¸ Edge Case
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
If target < all elements:
â†’ end = -1
â†’ return -1 (no floor exists)

ğŸ“Š Time & Space Complexity
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Time Complexity: O(log n)
â€¢ Space Complexity: O(1)

âœ… Summary Table
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Variable	Meaning
start	Points to first element > target
end	Points to last element â‰¤ target (floor)
mid	Temporary midpoint for comparison

ğŸš« Therefore: always return nums[end], not nums[mid].

ğŸ” Mirror Concept: Ceiling of a Number
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
For the "Ceiling" (smallest element â‰¥ target):
â€¢ If nums[mid] < target â†’ move right (start = mid + 1)
â€¢ Else â†’ move left (end = mid - 1)
â€¢ Return nums[start]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

yaml
Copy code

---




